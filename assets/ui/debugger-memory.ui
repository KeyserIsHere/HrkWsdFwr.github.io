(gui "debugger-memory"
    (namespace! :debugger-memory)
    (state! ".colour" (0 0 0))
    (state! ".change-colour" (255 0 0))
    (state! ".instruction-colour" (50 50 50))
    (state! ".read-breakpoint-colour" (0 255 0))
    (state! ".write-breakpoint-colour" (0 0 255))
    (state! ".breakpoint-colour" (0 255 255))
    (state! ".text-alignment" :center)
    (state! ".bytes" (quote (begin
        (state! ".modified")
        (state! ".parts")

        (.modified! (unquote (flatten flatten (loop "@item" .memory-modified
            (if (= 0 (get 0 @item))
                ((- (get 1 @item) 1))
                (if (= 255 (+ (get 0 @item) (get 1 @item)))
                    ((- (get 0 @item) (get 1 @item)))
                    (+ @item (-1 (- (get 0 @item) 1)))
                )
            )
        ))))
        (.parts!
            (chop (+ (* .modified 3) 2) (cat (loop "@line" (parts 16 .memory)
                (format :hex @line (compact: #f) (precision: 2) (separator: " "))
            ) "\n"))
        )

        ;TODO: add list value type for text colour fields so we don't need to flatten?
        (if (= 2 (count .memory-modified))
            (
                (text: (get 0 .parts) (flatten colour: .change-colour))
                (text: (get 1 .parts) (flatten colour: .colour))
                (text: (get 2 .parts) (flatten colour: .change-colour))
            ) ;(0 2)
            (if (= 1 (count .memory-modified))
                (if (= 2 (count .parts))
                    (if (= 0 (get 0 (get 0 .memory-modified)))
                        ((text: (get 0 .parts) (flatten colour: .change-colour)) (text: (get 1 .parts) (flatten colour: .colour))) ;(0)
                        ((text: (get 0 .parts) (flatten colour: .colour)) (text: (get 1 .parts) (flatten colour: .change-colour))) ;(1)
                    )
                    (
                        (text: (get 0 .parts) (flatten colour: .colour))
                        (text: (get 1 .parts) (flatten colour: .change-colour))
                        (text: (get 2 .parts) (flatten colour: .colour))
                    ) ;(1)
                )
                (text: (get 0 .parts) (flatten colour: .colour)) ;()
            )
        )
    )) (invalidate: (quote .memory-changed)))

    (state! ".text" (quote (render-text .rect .bytes (align: .text-alignment) (wrap: :word :multi) (offset: 0) (length: :max))) (invalidate: (quote (frame-changed?)))) ;TODO: set invalidate on either .memory-changed or rect change

    (state! ".instruction-marker" (quote (repeat "@index" (get 0 (disassemble .memory .pc))
        (begin
            (state! ".offset" (if (>= 255 (+ @index .pc)) (+ @index .pc) (- (+ @index .pc) 256)))
            (render-rect (- (flatten (text-cursor-position .text (+ (- (* .offset 3) (/ .offset 16)) 1)) 23 20) (13 5)) .instruction-colour) ;TODO: add text-selection-bounds to retrieve actual bounds for the given glyph range (likely return a list of rects)
        )
    )) (invalidate: (quote (frame-changed?)))) ;TODO: set invalidate on either .pc-changed or rect change

    ;TODO: Need to think about a better way to represent breakpoints
    (state! ".breakpoint-markers" (quote
        (loop "@bp" .breakpoints
            (render-rect (- (flatten (text-cursor-position .text (+ (- (* (get 0 @bp) 3) (/ (get 0 @bp) 16)) 1)) 20 20) (10 5)) (0 0 0 0) ;TODO: add text-selection-bounds to retrieve actual bounds for the given glyph range (likely return a list of rects)
                (outline: 2
                    (if (= (get 1 @bp) :read)
                        .read-breakpoint-colour
                        (if (= (get 1 @bp) :write)
                            .write-breakpoint-colour
                            .breakpoint-colour
                        )
                    )
                )
            )
        )
    ) (invalidate: (quote (frame-changed?)))) ;TODO: set invalidate on either .breakpoints-changed or rect change

    (render:
        .instruction-marker
        .text
        .breakpoint-markers
    )
)
